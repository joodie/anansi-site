(ns anansi.html-helpers
  (:use [hiccup core page-helpers]
        ring.util.codec
        anansi.validation.predicates
        [clojure.contrib.string :only [split join split-lines]]))

(defn add-class 
  "Add class c to element. Does not replace any original classes"
  [[tag & rest] c]
  (into [(keyword (str (name tag)  "." c))] rest))

(defn with-class
  "decorator that adds class c to the element generated by the wrapped function"
  [f c]
  (fn [& args]
    (add-class (apply f args) c)))

(defn add-attribute
  "Add an attribute to the specified tag"
  [name value [tagname & rst]]
  (let [[attrs content] (if (map? (first rst))
                            [(first rst) (rest rst)]
                            [{} rest])]
    (into [tagname (assoc attrs name value)] content)))

(defn button-link 
 [to & body]
 (add-class (link-to to body) "button"))

(defn string->html
  [text]
  (.. (str text)
      (replaceAll "&" "&amp;") 
      (replaceAll ">" "&gt;")
      (replaceAll "<" "&lt;")))

(defn email-link
  [address]
  (if (blank? address)
    ""
    (link-to (str "mailto:" (url-encode address)) address)))


(def ^{:private true}
  dd-re #"^([^<>:]{2,40}):([^/].*)")

(defn- parse-dl
  "transform 'Definiton: term' lists into '<th>Definition:</th><td>term</td>'"
  [s]
  (loop [input (split-lines s)
         output ""
         pairs ""]
    (if-let [line (first input)]
      ;; check if we have at least two lines of definitions
      ;; current definition in dt dd
      (if-let [[_ dt dd] (and (or (not (empty? pairs))
                                  (and (second input)
                                       (re-matches dd-re (second input))))
                              (re-matches dd-re line))]
         (recur (next input) output (str pairs "<tr><th>" dt "</th><td>" dd "</td></tr>"))
         (if (empty? pairs)
           (recur (next input) (str output line "\r\n") pairs)
           (recur (next input) (str output "<table>" pairs "</table>" line "\r\n") "")))
       (if (empty? pairs)
         output
         (str output "<table>" pairs "</table>")))))

(defn- parse-links
  [s]
  ;; note that urls are assumed not to end in . and some other punctuation
  (-> s
      (.replaceAll "\\b((http|ftp|https)://[^\\s<>\"':]*[^\\s<>\"':.?!()])" "<a href=\"$1\" target=\"_blank\">$1</a>")
      (.replaceAll "\\s(www\\.[^\\s<>\"':]*[^\\s<>\"':.?!()])" " <a href=\"http://$1\" target=\"_blank\">http://$1</a>")))

(defn text->html 
  [text]
  [:p (-> text
          string->html
          parse-links
          parse-dl
          (.replaceAll "\r\n\r\n" "</p><p>")        
          (.replaceAll "\r\n" "<br />")
          )])

(defn table
  ([rows]
     (table {} rows))
  ([attrs rows]
     [:table attrs [:tbody (map (fn [r] (map (fn [c] [:td c]) r)) rows)]]))

(defn- text->columns
  [n s]
  (let [ps (split #"\r?\n[\r?\n]+" (or s ""))
        c (Math/ceil (/ (count ps) n))]
    (map #(join "\r\n\r\n" %) (partition c c [] ps))))


(defn text->html-columns
  [n s]
  [:div.columns
   (concat (interpose [:div.column-spacer] (map (fn [t] [:div.column (text->html t)]) (text->columns n s))) [[:div.end-column]])])

